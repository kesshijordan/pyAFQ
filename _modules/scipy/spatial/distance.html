

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>scipy.spatial.distance &mdash; AFQ 0.1.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  

  
    <link rel="top" title="AFQ 0.1.0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../../../index.html" class="fa fa-home"> AFQ</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_tract_profile.html">Plotting a tract profile</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/AFQ.html"><code class="docutils literal"><span class="pre">AFQ</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/AFQ.api.html"><code class="docutils literal"><span class="pre">api</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/AFQ.csd.html"><code class="docutils literal"><span class="pre">csd</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/AFQ.data.html"><code class="docutils literal"><span class="pre">data</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/AFQ.dki.html"><code class="docutils literal"><span class="pre">dki</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/AFQ.dti.html"><code class="docutils literal"><span class="pre">dti</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/AFQ.registration.html"><code class="docutils literal"><span class="pre">registration</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/AFQ.segmentation.html"><code class="docutils literal"><span class="pre">segmentation</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../reference/AFQ.tractography.html"><code class="docutils literal"><span class="pre">tractography</span></code></a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">AFQ</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>scipy.spatial.distance</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for scipy.spatial.distance</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">=====================================================</span>
<span class="sd">Distance computations (:mod:`scipy.spatial.distance`)</span>
<span class="sd">=====================================================</span>

<span class="sd">.. sectionauthor:: Damian Eads</span>

<span class="sd">Function Reference</span>
<span class="sd">------------------</span>

<span class="sd">Distance matrix computation from a collection of raw observation vectors</span>
<span class="sd">stored in a rectangular array.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   pdist   -- pairwise distances between observation vectors.</span>
<span class="sd">   cdist   -- distances between two collections of observation vectors</span>
<span class="sd">   squareform -- convert distance matrix to a condensed one and vice versa</span>

<span class="sd">Predicates for checking the validity of distance matrices, both</span>
<span class="sd">condensed and redundant. Also contained in this module are functions</span>
<span class="sd">for computing the number of observations in a distance matrix.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   is_valid_dm -- checks for a valid distance matrix</span>
<span class="sd">   is_valid_y  -- checks for a valid condensed distance matrix</span>
<span class="sd">   num_obs_dm  -- # of observations in a distance matrix</span>
<span class="sd">   num_obs_y   -- # of observations in a condensed distance matrix</span>

<span class="sd">Distance functions between two vectors ``u`` and ``v``. Computing</span>
<span class="sd">distances over a large collection of vectors is inefficient for these</span>
<span class="sd">functions. Use ``pdist`` for this purpose.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   braycurtis       -- the Bray-Curtis distance.</span>
<span class="sd">   canberra         -- the Canberra distance.</span>
<span class="sd">   chebyshev        -- the Chebyshev distance.</span>
<span class="sd">   cityblock        -- the Manhattan distance.</span>
<span class="sd">   correlation      -- the Correlation distance.</span>
<span class="sd">   cosine           -- the Cosine distance.</span>
<span class="sd">   dice             -- the Dice dissimilarity (boolean).</span>
<span class="sd">   euclidean        -- the Euclidean distance.</span>
<span class="sd">   hamming          -- the Hamming distance (boolean).</span>
<span class="sd">   jaccard          -- the Jaccard distance (boolean).</span>
<span class="sd">   kulsinski        -- the Kulsinski distance (boolean).</span>
<span class="sd">   mahalanobis      -- the Mahalanobis distance.</span>
<span class="sd">   matching         -- the matching dissimilarity (boolean).</span>
<span class="sd">   minkowski        -- the Minkowski distance.</span>
<span class="sd">   rogerstanimoto   -- the Rogers-Tanimoto dissimilarity (boolean).</span>
<span class="sd">   russellrao       -- the Russell-Rao dissimilarity (boolean).</span>
<span class="sd">   seuclidean       -- the normalized Euclidean distance.</span>
<span class="sd">   sokalmichener    -- the Sokal-Michener dissimilarity (boolean).</span>
<span class="sd">   sokalsneath      -- the Sokal-Sneath dissimilarity (boolean).</span>
<span class="sd">   sqeuclidean      -- the squared Euclidean distance.</span>
<span class="sd">   wminkowski       -- the weighted Minkowski distance.</span>
<span class="sd">   yule             -- the Yule dissimilarity (boolean).</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># Copyright (C) Damian Eads, 2007-2008. New BSD License.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&#39;braycurtis&#39;</span><span class="p">,</span>
    <span class="s">&#39;canberra&#39;</span><span class="p">,</span>
    <span class="s">&#39;cdist&#39;</span><span class="p">,</span>
    <span class="s">&#39;chebyshev&#39;</span><span class="p">,</span>
    <span class="s">&#39;cityblock&#39;</span><span class="p">,</span>
    <span class="s">&#39;correlation&#39;</span><span class="p">,</span>
    <span class="s">&#39;cosine&#39;</span><span class="p">,</span>
    <span class="s">&#39;dice&#39;</span><span class="p">,</span>
    <span class="s">&#39;euclidean&#39;</span><span class="p">,</span>
    <span class="s">&#39;hamming&#39;</span><span class="p">,</span>
    <span class="s">&#39;is_valid_dm&#39;</span><span class="p">,</span>
    <span class="s">&#39;is_valid_y&#39;</span><span class="p">,</span>
    <span class="s">&#39;jaccard&#39;</span><span class="p">,</span>
    <span class="s">&#39;kulsinski&#39;</span><span class="p">,</span>
    <span class="s">&#39;mahalanobis&#39;</span><span class="p">,</span>
    <span class="s">&#39;matching&#39;</span><span class="p">,</span>
    <span class="s">&#39;minkowski&#39;</span><span class="p">,</span>
    <span class="s">&#39;num_obs_dm&#39;</span><span class="p">,</span>
    <span class="s">&#39;num_obs_y&#39;</span><span class="p">,</span>
    <span class="s">&#39;pdist&#39;</span><span class="p">,</span>
    <span class="s">&#39;rogerstanimoto&#39;</span><span class="p">,</span>
    <span class="s">&#39;russellrao&#39;</span><span class="p">,</span>
    <span class="s">&#39;seuclidean&#39;</span><span class="p">,</span>
    <span class="s">&#39;sokalmichener&#39;</span><span class="p">,</span>
    <span class="s">&#39;sokalsneath&#39;</span><span class="p">,</span>
    <span class="s">&#39;sqeuclidean&#39;</span><span class="p">,</span>
    <span class="s">&#39;squareform&#39;</span><span class="p">,</span>
    <span class="s">&#39;wminkowski&#39;</span><span class="p">,</span>
    <span class="s">&#39;yule&#39;</span>
<span class="p">]</span>


<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">scipy._lib.six</span> <span class="kn">import</span> <span class="nb">callable</span><span class="p">,</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">scipy._lib.six</span> <span class="kn">import</span> <span class="nb">xrange</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_distance_wrap</span>
<span class="kn">from</span> <span class="nn">..linalg</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">import</span> <span class="nn">collections</span>


<span class="k">def</span> <span class="nf">_copy_array_if_base_present</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copies the array if its base points to a parent array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubsctype</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_copy_arrays_if_base_present</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Accepts a tuple of arrays T. Copies the array T[i] if its base array</span>
<span class="sd">    points to an actual array. Otherwise, the reference is just copied.</span>
<span class="sd">    This is useful if the arrays are being passed to a C function that</span>
<span class="sd">    does not do proper striding.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">_copy_array_if_base_present</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">T</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">l</span>


<span class="k">def</span> <span class="nf">_convert_to_bool</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">X</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">contiguous</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">X</span>


<span class="k">def</span> <span class="nf">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">X</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">contiguous</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">X</span>


<span class="k">def</span> <span class="nf">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># XXX Is order=&#39;c&#39; really necessary?</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="c"># Ensure values such as u=1 and u=[1] still return 1-D arrays.</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Input vector should be 1-D.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span>


<span class="k">def</span> <span class="nf">minkowski</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Minkowski distance between two 1-D arrays.</span>

<span class="sd">    The Minkowski distance between 1-D arrays `u` and `v`,</span>
<span class="sd">    is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       {||u-v||}_p = (\\sum{|u_i - v_i|^p})^{1/p}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    p : int</span>
<span class="sd">        The order of the norm of the difference :math:`{||u-v||}_p`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    d : double</span>
<span class="sd">        The Minkowski distance between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;p must be at least 1&quot;</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dist</span>


<span class="k">def</span> <span class="nf">wminkowski</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the weighted Minkowski distance between two 1-D arrays.</span>

<span class="sd">    The weighted Minkowski distance between `u` and `v`, defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\left(\\sum{(w_i |u_i - v_i|^p)}\\right)^{1/p}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    p : int</span>
<span class="sd">        The order of the norm of the difference :math:`{||u-v||}_p`.</span>
<span class="sd">    w : (N,) array_like</span>
<span class="sd">        The weight vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wminkowski : double</span>
<span class="sd">        The weighted Minkowski distance between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;p must be at least 1&quot;</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">),</span> <span class="nb">ord</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dist</span>


<span class="k">def</span> <span class="nf">euclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Euclidean distance between two 1-D arrays.</span>

<span class="sd">    The Euclidean distance between 1-D arrays `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       {||u-v||}_2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    euclidean : double</span>
<span class="sd">        The Euclidean distance between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dist</span>


<span class="k">def</span> <span class="nf">sqeuclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the squared Euclidean distance between two 1-D arrays.</span>

<span class="sd">    The squared Euclidean distance between `u` and `v` is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       {||u-v||}_2^2.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sqeuclidean : double</span>
<span class="sd">        The squared Euclidean distance between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Preserve float dtypes, but convert everything else to np.float64</span>
    <span class="c"># for stability.</span>
    <span class="n">utype</span><span class="p">,</span> <span class="n">vtype</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="s">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">)):</span>
        <span class="n">utype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">)):</span>
        <span class="n">vtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">utype</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vtype</span><span class="p">)</span>
    <span class="n">u_v</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_v</span><span class="p">,</span> <span class="n">u_v</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">cosine</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Cosine distance between 1-D arrays.</span>

<span class="sd">    The Cosine distance between `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       1 - \\frac{u \\cdot v}</span>
<span class="sd">                {||u||_2 ||v||_2}.</span>

<span class="sd">    where :math:`u \\cdot v` is the dot product of :math:`u` and</span>
<span class="sd">    :math:`v`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cosine : double</span>
<span class="sd">        The Cosine distance between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dist</span>


<span class="k">def</span> <span class="nf">correlation</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the correlation distance between two 1-D arrays.</span>

<span class="sd">    The correlation distance between `u` and `v`, is</span>
<span class="sd">    defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}</span>
<span class="sd">               {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}</span>

<span class="sd">    where :math:`\\bar{u}` is the mean of the elements of `u`</span>
<span class="sd">    and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    correlation : double</span>
<span class="sd">        The correlation distance between 1-D array `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">umu</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">vmu</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">um</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">umu</span>
    <span class="n">vm</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">vmu</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">um</span><span class="p">,</span> <span class="n">vm</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">um</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">vm</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dist</span>


<span class="k">def</span> <span class="nf">hamming</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Hamming distance between two 1-D arrays.</span>

<span class="sd">    The Hamming distance between 1-D arrays `u` and `v`, is simply the</span>
<span class="sd">    proportion of disagreeing components in `u` and `v`. If `u` and `v` are</span>
<span class="sd">    boolean vectors, the Hamming distance is</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\frac{c_{01} + c_{10}}{n}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hamming : double</span>
<span class="sd">        The Hamming distance between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;The 1d arrays must have equal lengths.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">jaccard</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Jaccard-Needham dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Jaccard-Needham dissimilarity between 1-D boolean arrays `u` and `v`,</span>
<span class="sd">    is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\frac{c_{TF} + c_{FT}}</span>
<span class="sd">            {c_{TT} + c_{FT} + c_{TF}}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jaccard : double</span>
<span class="sd">        The Jaccard distance between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">((</span><span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">),</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">dist</span>


<span class="k">def</span> <span class="nf">kulsinski</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Kulsinski dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Kulsinski dissimilarity between two boolean 1-D arrays `u` and `v`,</span>
<span class="sd">    is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">         \\frac{c_{TF} + c_{FT} - c_{TT} + n}</span>
<span class="sd">              {c_{FT} + c_{TF} + n}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kulsinski : double</span>
<span class="sd">        The Kulsinski distance between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
    <span class="p">(</span><span class="n">nff</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span> <span class="o">-</span> <span class="n">ntt</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">seuclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the standardized Euclidean distance between two 1-D arrays.</span>

<span class="sd">    The standardized Euclidean distance between `u` and `v`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    V : (N,) array_like</span>
<span class="sd">        `V` is an 1-D array of component variances. It is usually computed</span>
<span class="sd">        among a larger collection vectors.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    seuclidean : double</span>
<span class="sd">        The standardized Euclidean distance between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;V must be a 1-D array of the same dimension &#39;</span>
                        <span class="s">&#39;as u and v.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">cityblock</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the City Block (Manhattan) distance.</span>

<span class="sd">    Computes the Manhattan distance between two 1-D arrays `u` and `v`,</span>
<span class="sd">    which is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sum_i {\\left| u_i - v_i \\right|}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cityblock : double</span>
<span class="sd">        The City Block (Manhattan) distance between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>


<div class="viewcode-block" id="mahalanobis"><a class="viewcode-back" href="../../../reference/AFQ.segmentation.html#AFQ.segmentation.mahalanobis">[docs]</a><span class="k">def</span> <span class="nf">mahalanobis</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">VI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Mahalanobis distance between two 1-D arrays.</span>

<span class="sd">    The Mahalanobis distance between 1-D arrays `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sqrt{ (u-v) V^{-1} (u-v)^T }</span>

<span class="sd">    where ``V`` is the covariance matrix.  Note that the argument `VI`</span>
<span class="sd">    is the inverse of ``V``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    VI : ndarray</span>
<span class="sd">        The inverse of the covariance matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mahalanobis : double</span>
<span class="sd">        The Mahalanobis distance between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">VI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">VI</span><span class="p">)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">VI</span><span class="p">),</span> <span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">chebyshev</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Chebyshev distance.</span>

<span class="sd">    Computes the Chebyshev distance between two 1-D arrays `u` and `v`,</span>
<span class="sd">    which is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\max_i {|u_i-v_i|}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input vector.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chebyshev : double</span>
<span class="sd">        The Chebyshev distance between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">braycurtis</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Bray-Curtis distance between two 1-D arrays.</span>

<span class="sd">    Bray-Curtis distance is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sum{|u_i-v_i|} / \\sum{|u_i+v_i|}</span>

<span class="sd">    The Bray-Curtis distance is in the range [0, 1] if all coordinates are</span>
<span class="sd">    positive, and is undefined if the inputs are of length zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    braycurtis : double</span>
<span class="sd">        The Bray-Curtis distance between 1-D arrays `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">canberra</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Canberra distance between two 1-D arrays.</span>

<span class="sd">    The Canberra distance is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">         d(u,v) = \\sum_i \\frac{|u_i-v_i|}</span>
<span class="sd">                              {|u_i|+|v_i|}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    canberra : double</span>
<span class="sd">        The Canberra distance between vectors `u` and `v`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When `u[i]` and `v[i]` are 0 for given i, then the fraction 0/0 = 0 is</span>
<span class="sd">    used in the calculation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">olderr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s">&#39;ignore&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">olderr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span> <span class="nf">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Arrays being compared must be of the same data type.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float_</span> <span class="ow">or</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
        <span class="n">not_u</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">u</span>
        <span class="n">not_v</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">v</span>
        <span class="n">nff</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">*</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">not_u</span> <span class="o">=</span> <span class="o">~</span><span class="n">u</span>
        <span class="n">not_v</span> <span class="o">=</span> <span class="o">~</span><span class="n">v</span>
        <span class="n">nff</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">&amp;</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Arrays being compared have unknown type.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">nff</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_nbool_correspond_ft_tf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float_</span> <span class="ow">or</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
        <span class="n">not_u</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">u</span>
        <span class="n">not_v</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">v</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">not_u</span> <span class="o">=</span> <span class="o">~</span><span class="n">u</span>
        <span class="n">not_v</span> <span class="o">=</span> <span class="o">~</span><span class="n">v</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">yule</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Yule dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Yule dissimilarity is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">         \\frac{R}{c_{TT} * c_{FF} + \\frac{R}{2}}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n` and :math:`R = 2.0 * c_{TF} * c_{FT}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    yule : double</span>
<span class="sd">        The Yule dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="p">(</span><span class="n">nff</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ntf</span> <span class="o">*</span> <span class="n">nft</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ntt</span> <span class="o">*</span> <span class="n">nff</span> <span class="o">+</span> <span class="n">ntf</span> <span class="o">*</span> <span class="n">nft</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">matching</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Matching dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Matching dissimilarity between two boolean 1-D arrays</span>
<span class="sd">    `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\frac{c_{TF} + c_{FT}}{n}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    matching : double</span>
<span class="sd">        The Matching dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="p">(</span><span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_ft_tf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">nft</span> <span class="o">+</span> <span class="n">ntf</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">dice</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Dice dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Dice dissimilarity between `u` and `v`, is</span>

<span class="sd">    .. math::</span>

<span class="sd">         \\frac{c_{TF} + c_{FT}}</span>
<span class="sd">              {2c_{TT} + c_{FT} + c_{TF}}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) ndarray, bool</span>
<span class="sd">        Input 1-D array.</span>
<span class="sd">    v : (N,) ndarray, bool</span>
<span class="sd">        Input 1-D array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dice : double</span>
<span class="sd">        The Dice dissimilarity between 1-D arrays `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">(</span><span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_ft_tf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ntt</span> <span class="o">+</span> <span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">rogerstanimoto</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Rogers-Tanimoto dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Rogers-Tanimoto dissimilarity between two boolean 1-D arrays</span>
<span class="sd">    `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">       \\frac{R}</span>
<span class="sd">            {c_{TT} + c_{FF} + R}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n` and :math:`R = 2(c_{TF} + c_{FT})`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rogerstanimoto : double</span>
<span class="sd">        The Rogers-Tanimoto dissimilarity between vectors</span>
<span class="sd">        `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="p">(</span><span class="n">nff</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ntt</span> <span class="o">+</span> <span class="n">nff</span> <span class="o">+</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">russellrao</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Russell-Rao dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Russell-Rao dissimilarity between two boolean 1-D arrays, `u` and</span>
<span class="sd">    `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">      \\frac{n - c_{TT}}</span>
<span class="sd">           {n}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    russellrao : double</span>
<span class="sd">        The Russell-Rao dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="n">ntt</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">sokalmichener</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Sokal-Michener dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Sokal-Michener dissimilarity between boolean 1-D arrays `u` and `v`,</span>
<span class="sd">    is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\frac{R}</span>
<span class="sd">            {S + R}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`, :math:`R = 2 * (c_{TF} + c_{FT})` and</span>
<span class="sd">    :math:`S = c_{FF} + c_{TT}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sokalmichener : double</span>
<span class="sd">        The Sokal-Michener dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nff</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">u</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nff</span> <span class="o">=</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">(</span><span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_ft_tf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ntt</span> <span class="o">+</span> <span class="n">nff</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">sokalsneath</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Sokal-Sneath dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Sokal-Sneath dissimilarity between `u` and `v`,</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\frac{R}</span>
<span class="sd">            {c_{TT} + R}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n` and :math:`R = 2(c_{TF} + c_{FT})`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sokalsneath : double</span>
<span class="sd">        The Sokal-Sneath dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">(</span><span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_ft_tf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">ntt</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Sokal-Sneath dissimilarity is not defined for &#39;</span>
                            <span class="s">&#39;vectors that are entirely false.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span> <span class="o">/</span> <span class="n">denom</span>


<span class="k">def</span> <span class="nf">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s">&#39;euclidean&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">VI</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pairwise distances between observations in n-dimensional space.</span>

<span class="sd">    The following are common calling conventions.</span>

<span class="sd">    1. ``Y = pdist(X, &#39;euclidean&#39;)``</span>

<span class="sd">       Computes the distance between m points using Euclidean distance</span>
<span class="sd">       (2-norm) as the distance metric between the points. The points</span>
<span class="sd">       are arranged as m n-dimensional row vectors in the matrix X.</span>

<span class="sd">    2. ``Y = pdist(X, &#39;minkowski&#39;, p)``</span>

<span class="sd">       Computes the distances using the Minkowski distance</span>
<span class="sd">       :math:`||u-v||_p` (p-norm) where :math:`p \\geq 1`.</span>

<span class="sd">    3. ``Y = pdist(X, &#39;cityblock&#39;)``</span>

<span class="sd">       Computes the city block or Manhattan distance between the</span>
<span class="sd">       points.</span>

<span class="sd">    4. ``Y = pdist(X, &#39;seuclidean&#39;, V=None)``</span>

<span class="sd">       Computes the standardized Euclidean distance. The standardized</span>
<span class="sd">       Euclidean distance between two n-vectors ``u`` and ``v`` is</span>

<span class="sd">       .. math::</span>

<span class="sd">          \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}</span>


<span class="sd">       V is the variance vector; V[i] is the variance computed over all</span>
<span class="sd">       the i&#39;th components of the points.  If not passed, it is</span>
<span class="sd">       automatically computed.</span>

<span class="sd">    5. ``Y = pdist(X, &#39;sqeuclidean&#39;)``</span>

<span class="sd">       Computes the squared Euclidean distance :math:`||u-v||_2^2` between</span>
<span class="sd">       the vectors.</span>

<span class="sd">    6. ``Y = pdist(X, &#39;cosine&#39;)``</span>

<span class="sd">       Computes the cosine distance between vectors u and v,</span>

<span class="sd">       .. math::</span>

<span class="sd">          1 - \\frac{u \\cdot v}</span>
<span class="sd">                   {{||u||}_2 {||v||}_2}</span>

<span class="sd">       where :math:`||*||_2` is the 2-norm of its argument ``*``, and</span>
<span class="sd">       :math:`u \\cdot v` is the dot product of ``u`` and ``v``.</span>

<span class="sd">    7. ``Y = pdist(X, &#39;correlation&#39;)``</span>

<span class="sd">       Computes the correlation distance between vectors u and v. This is</span>

<span class="sd">       .. math::</span>

<span class="sd">          1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}</span>
<span class="sd">                   {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}</span>

<span class="sd">       where :math:`\\bar{v}` is the mean of the elements of vector v,</span>
<span class="sd">       and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.</span>

<span class="sd">    8. ``Y = pdist(X, &#39;hamming&#39;)``</span>

<span class="sd">       Computes the normalized Hamming distance, or the proportion of</span>
<span class="sd">       those vector elements between two n-vectors ``u`` and ``v``</span>
<span class="sd">       which disagree. To save memory, the matrix ``X`` can be of type</span>
<span class="sd">       boolean.</span>

<span class="sd">    9. ``Y = pdist(X, &#39;jaccard&#39;)``</span>

<span class="sd">       Computes the Jaccard distance between the points. Given two</span>
<span class="sd">       vectors, ``u`` and ``v``, the Jaccard distance is the</span>
<span class="sd">       proportion of those elements ``u[i]`` and ``v[i]`` that</span>
<span class="sd">       disagree where at least one of them is non-zero.</span>

<span class="sd">    10. ``Y = pdist(X, &#39;chebyshev&#39;)``</span>

<span class="sd">       Computes the Chebyshev distance between the points. The</span>
<span class="sd">       Chebyshev distance between two n-vectors ``u`` and ``v`` is the</span>
<span class="sd">       maximum norm-1 distance between their respective elements. More</span>
<span class="sd">       precisely, the distance is given by</span>

<span class="sd">       .. math::</span>

<span class="sd">          d(u,v) = \\max_i {|u_i-v_i|}</span>

<span class="sd">    11. ``Y = pdist(X, &#39;canberra&#39;)``</span>

<span class="sd">       Computes the Canberra distance between the points. The</span>
<span class="sd">       Canberra distance between two points ``u`` and ``v`` is</span>

<span class="sd">       .. math::</span>

<span class="sd">         d(u,v) = \\sum_i \\frac{|u_i-v_i|}</span>
<span class="sd">                              {|u_i|+|v_i|}</span>


<span class="sd">    12. ``Y = pdist(X, &#39;braycurtis&#39;)``</span>

<span class="sd">       Computes the Bray-Curtis distance between the points. The</span>
<span class="sd">       Bray-Curtis distance between two points ``u`` and ``v`` is</span>


<span class="sd">       .. math::</span>

<span class="sd">            d(u,v) = \\frac{\\sum_i {u_i-v_i}}</span>
<span class="sd">                          {\\sum_i {u_i+v_i}}</span>

<span class="sd">    13. ``Y = pdist(X, &#39;mahalanobis&#39;, VI=None)``</span>

<span class="sd">       Computes the Mahalanobis distance between the points. The</span>
<span class="sd">       Mahalanobis distance between two points ``u`` and ``v`` is</span>
<span class="sd">       :math:`(u-v)(1/V)(u-v)^T` where :math:`(1/V)` (the ``VI``</span>
<span class="sd">       variable) is the inverse covariance. If ``VI`` is not None,</span>
<span class="sd">       ``VI`` will be used as the inverse covariance matrix.</span>

<span class="sd">    14. ``Y = pdist(X, &#39;yule&#39;)``</span>

<span class="sd">       Computes the Yule distance between each pair of boolean</span>
<span class="sd">       vectors. (see yule function documentation)</span>

<span class="sd">    15. ``Y = pdist(X, &#39;matching&#39;)``</span>

<span class="sd">       Computes the matching distance between each pair of boolean</span>
<span class="sd">       vectors. (see matching function documentation)</span>

<span class="sd">    16. ``Y = pdist(X, &#39;dice&#39;)``</span>

<span class="sd">       Computes the Dice distance between each pair of boolean</span>
<span class="sd">       vectors. (see dice function documentation)</span>

<span class="sd">    17. ``Y = pdist(X, &#39;kulsinski&#39;)``</span>

<span class="sd">       Computes the Kulsinski distance between each pair of</span>
<span class="sd">       boolean vectors. (see kulsinski function documentation)</span>

<span class="sd">    18. ``Y = pdist(X, &#39;rogerstanimoto&#39;)``</span>

<span class="sd">       Computes the Rogers-Tanimoto distance between each pair of</span>
<span class="sd">       boolean vectors. (see rogerstanimoto function documentation)</span>

<span class="sd">    19. ``Y = pdist(X, &#39;russellrao&#39;)``</span>

<span class="sd">       Computes the Russell-Rao distance between each pair of</span>
<span class="sd">       boolean vectors. (see russellrao function documentation)</span>

<span class="sd">    20. ``Y = pdist(X, &#39;sokalmichener&#39;)``</span>

<span class="sd">       Computes the Sokal-Michener distance between each pair of</span>
<span class="sd">       boolean vectors. (see sokalmichener function documentation)</span>

<span class="sd">    21. ``Y = pdist(X, &#39;sokalsneath&#39;)``</span>

<span class="sd">       Computes the Sokal-Sneath distance between each pair of</span>
<span class="sd">       boolean vectors. (see sokalsneath function documentation)</span>

<span class="sd">    22. ``Y = pdist(X, &#39;wminkowski&#39;)``</span>

<span class="sd">       Computes the weighted Minkowski distance between each pair of</span>
<span class="sd">       vectors. (see wminkowski function documentation)</span>

<span class="sd">    23. ``Y = pdist(X, f)``</span>

<span class="sd">       Computes the distance between all pairs of vectors in X</span>
<span class="sd">       using the user supplied 2-arity function f. For example,</span>
<span class="sd">       Euclidean distance between the vectors could be computed</span>
<span class="sd">       as follows::</span>

<span class="sd">         dm = pdist(X, lambda u, v: np.sqrt(((u-v)**2).sum()))</span>

<span class="sd">       Note that you should avoid passing a reference to one of</span>
<span class="sd">       the distance functions defined in this library. For example,::</span>

<span class="sd">         dm = pdist(X, sokalsneath)</span>

<span class="sd">       would calculate the pair-wise distances between the vectors in</span>
<span class="sd">       X using the Python function sokalsneath. This would result in</span>
<span class="sd">       sokalsneath being called :math:`{n \\choose 2}` times, which</span>
<span class="sd">       is inefficient. Instead, the optimized C version is more</span>
<span class="sd">       efficient, and we call it using the following syntax.::</span>

<span class="sd">         dm = pdist(X, &#39;sokalsneath&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray</span>
<span class="sd">        An m by n array of m original observations in an</span>
<span class="sd">        n-dimensional space.</span>
<span class="sd">    metric : str or function, optional</span>
<span class="sd">        The distance metric to use. The distance function can</span>
<span class="sd">        be &#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;, &#39;cityblock&#39;,</span>
<span class="sd">        &#39;correlation&#39;, &#39;cosine&#39;, &#39;dice&#39;, &#39;euclidean&#39;, &#39;hamming&#39;,</span>
<span class="sd">        &#39;jaccard&#39;, &#39;kulsinski&#39;, &#39;mahalanobis&#39;, &#39;matching&#39;,</span>
<span class="sd">        &#39;minkowski&#39;, &#39;rogerstanimoto&#39;, &#39;russellrao&#39;, &#39;seuclidean&#39;,</span>
<span class="sd">        &#39;sokalmichener&#39;, &#39;sokalsneath&#39;, &#39;sqeuclidean&#39;, &#39;yule&#39;.</span>
<span class="sd">    w : ndarray, optional</span>
<span class="sd">        The weight vector (for weighted Minkowski).</span>
<span class="sd">    p : double, optional</span>
<span class="sd">        The p-norm to apply (for Minkowski, weighted and unweighted)</span>
<span class="sd">    V : ndarray, optional</span>
<span class="sd">        The variance vector (for standardized Euclidean).</span>
<span class="sd">    VI : ndarray, optional</span>
<span class="sd">        The inverse of the covariance matrix (for Mahalanobis).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        Returns a condensed distance matrix Y.  For</span>
<span class="sd">        each :math:`i` and :math:`j` (where :math:`i&lt;j&lt;n`), the</span>
<span class="sd">        metric ``dist(u=X[i], v=X[j])`` is computed and stored in entry ``ij``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    squareform : converts between condensed distance matrices and</span>
<span class="sd">                 square distance matrices.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See ``squareform`` for information on how to calculate the index of</span>
<span class="sd">    this entry or to convert the condensed distance matrix to a</span>
<span class="sd">    redundant square matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="c">#         21. Y = pdist(X, &#39;test_Y&#39;)</span>
<span class="c">#</span>
<span class="c">#           Computes the distance between all pairs of vectors in X</span>
<span class="c">#           using the distance metric Y but with a more succinct,</span>
<span class="c">#           verifiable, but less efficient implementation.</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>

    <span class="c"># The C code doesn&#39;t do striding.</span>
    <span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_arrays_if_base_present</span><span class="p">([</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">)])</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;A 2-dimensional array must be passed.&#39;</span><span class="p">)</span>

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span>
    <span class="n">dm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

    <span class="n">wmink_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;wminkowski&#39;</span><span class="p">,</span> <span class="s">&#39;wmi&#39;</span><span class="p">,</span> <span class="s">&#39;wm&#39;</span><span class="p">,</span> <span class="s">&#39;wpnorm&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="n">wminkowski</span> <span class="ow">or</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">wmink_names</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;weighted minkowski requires a weight &#39;</span>
                            <span class="s">&#39;vector `w` to be given.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">minkowski</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dfun</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">minkowski</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">wminkowski</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dfun</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">wminkowski</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">seuclidean</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dfun</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">seuclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">mahalanobis</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">dfun</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">mahalanobis</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dfun</span> <span class="o">=</span> <span class="n">metric</span>

        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                <span class="n">dm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfun</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">mstr</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c">#if X.dtype != np.double and \</span>
        <span class="c">#       (mstr != &#39;hamming&#39; and mstr != &#39;jaccard&#39;):</span>
        <span class="c">#    TypeError(&#39;A double array must be passed.&#39;)</span>
        <span class="k">if</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s">&#39;euclid&#39;</span><span class="p">,</span> <span class="s">&#39;eu&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">]):</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_euclidean_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;sqeuclidean&#39;</span><span class="p">,</span> <span class="s">&#39;sqe&#39;</span><span class="p">,</span> <span class="s">&#39;sqeuclid&#39;</span><span class="p">]):</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_sqeuclidean_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;cityblock&#39;</span><span class="p">,</span> <span class="s">&#39;cblock&#39;</span><span class="p">,</span> <span class="s">&#39;cb&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">]):</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_city_block_wrap</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;hamming&#39;</span><span class="p">,</span> <span class="s">&#39;hamm&#39;</span><span class="p">,</span> <span class="s">&#39;ha&#39;</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_hamming_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_hamming_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s">&#39;jacc&#39;</span><span class="p">,</span> <span class="s">&#39;ja&#39;</span><span class="p">,</span> <span class="s">&#39;j&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_jaccard_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_jaccard_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;chebychev&#39;</span><span class="p">,</span> <span class="s">&#39;chebyshev&#39;</span><span class="p">,</span> <span class="s">&#39;cheby&#39;</span><span class="p">,</span> <span class="s">&#39;cheb&#39;</span><span class="p">,</span> <span class="s">&#39;ch&#39;</span><span class="p">]):</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_chebyshev_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;minkowski&#39;</span><span class="p">,</span> <span class="s">&#39;mi&#39;</span><span class="p">,</span> <span class="s">&#39;m&#39;</span><span class="p">]):</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_minkowski_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="n">wmink_names</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_weighted_minkowski_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">),</span>
                                                         <span class="n">dm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;seuclidean&#39;</span><span class="p">,</span> <span class="s">&#39;se&#39;</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Variance vector V must be a numpy array&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Variance vector V must contain doubles.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Variance vector V must &#39;</span>
                                     <span class="s">&#39;be one-dimensional.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Variance vector V must be of the same &#39;</span>
                            <span class="s">&#39;dimension as the vectors on which the distances &#39;</span>
                            <span class="s">&#39;are computed.&#39;</span><span class="p">)</span>
                <span class="c"># The C code doesn&#39;t do striding.</span>
                <span class="p">[</span><span class="n">VV</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_arrays_if_base_present</span><span class="p">([</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">V</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">VV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_seuclidean_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">VV</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;cosine&#39;</span><span class="p">,</span> <span class="s">&#39;cos&#39;</span><span class="p">]):</span>
            <span class="n">norms</span> <span class="o">=</span> <span class="n">_row_norms</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_cosine_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">norms</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;old_cosine&#39;</span><span class="p">,</span> <span class="s">&#39;old_cos&#39;</span><span class="p">]):</span>
            <span class="n">norms</span> <span class="o">=</span> <span class="n">_row_norms</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">nV</span> <span class="o">=</span> <span class="n">norms</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c"># The numerator u * v</span>
            <span class="n">nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c"># The denom. ||u||*||v||</span>
            <span class="n">de</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">nV</span><span class="p">,</span> <span class="n">nV</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">nm</span> <span class="o">/</span> <span class="n">de</span><span class="p">)</span>
            <span class="n">dm</span><span class="p">[</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;correlation&#39;</span><span class="p">,</span> <span class="s">&#39;co&#39;</span><span class="p">]):</span>
            <span class="n">X2</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">norms</span> <span class="o">=</span> <span class="n">_row_norms</span><span class="p">(</span><span class="n">X2</span><span class="p">)</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_cosine_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X2</span><span class="p">),</span>
                                             <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">dm</span><span class="p">),</span>
                                             <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">norms</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;mahalanobis&#39;</span><span class="p">,</span> <span class="s">&#39;mahal&#39;</span><span class="p">,</span> <span class="s">&#39;mah&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">VI</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">VI</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">VI</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">VI</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;VI must be a numpy array.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">VI</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;The array must contain 64-bit floats.&#39;</span><span class="p">)</span>
                <span class="p">[</span><span class="n">VI</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_arrays_if_base_present</span><span class="p">([</span><span class="n">VI</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
                    <span class="c"># There are fewer observations than the dimension of</span>
                    <span class="c"># the observations.</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The number of observations (</span><span class="si">%d</span><span class="s">) is too &quot;</span>
                                     <span class="s">&quot;small; the covariance matrix is &quot;</span>
                                     <span class="s">&quot;singular. For observations with </span><span class="si">%d</span><span class="s"> &quot;</span>
                                     <span class="s">&quot;dimensions, at least </span><span class="si">%d</span><span class="s"> observations &quot;</span>
                                     <span class="s">&quot;are required.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                <span class="n">VI</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="c"># (u-v)V^(-1)(u-v)^T</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_mahalanobis_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">),</span>
                                                  <span class="n">VI</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;canberra&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_canberra_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;braycurtis&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_bray_curtis_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;yule&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_yule_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;matching&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_matching_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;kulsinski&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_kulsinski_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;dice&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_dice_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;rogerstanimoto&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_rogerstanimoto_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">X</span><span class="p">),</span>
                                                          <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;russellrao&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_russellrao_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;sokalmichener&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_sokalmichener_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">X</span><span class="p">),</span>
                                                         <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;sokalsneath&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_sokalsneath_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_euclidean&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">euclidean</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_sqeuclidean&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">seuclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">V</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_braycurtis&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">braycurtis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_mahalanobis&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">VI</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">VI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">VI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">VI</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
            <span class="p">[</span><span class="n">VI</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_arrays_if_base_present</span><span class="p">([</span><span class="n">VI</span><span class="p">])</span>
            <span class="c"># (u-v)V^(-1)(u-v)^T</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">mahalanobis</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">VI</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_canberra&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">canberra</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_cityblock&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">cityblock</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_minkowski&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">minkowski</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_wminkowski&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">wminkowski</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_cosine&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">cosine</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_correlation&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">correlation</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_hamming&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">hamming</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_jaccard&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">jaccard</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_chebyshev&#39;</span> <span class="ow">or</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_chebychev&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">chebyshev</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_yule&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">yule</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_matching&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">matching</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_dice&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dice</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_kulsinski&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">kulsinski</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_rogerstanimoto&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">rogerstanimoto</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_russellrao&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">russellrao</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_sokalsneath&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sokalsneath</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_sokalmichener&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sokalmichener</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Unknown Distance Metric: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">mstr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;2nd argument metric must be a string identifier &#39;</span>
                        <span class="s">&#39;or a function.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dm</span>


<span class="k">def</span> <span class="nf">squareform</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="s">&quot;no&quot;</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a vector-form distance vector to a square-form distance</span>
<span class="sd">    matrix, and vice-versa.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray</span>
<span class="sd">        Either a condensed or redundant distance matrix.</span>
<span class="sd">    force : str, optional</span>
<span class="sd">        As with MATLAB(TM), if force is equal to &#39;tovector&#39; or &#39;tomatrix&#39;,</span>
<span class="sd">        the input will be treated as a distance matrix or distance vector</span>
<span class="sd">        respectively.</span>
<span class="sd">    checks : bool, optional</span>
<span class="sd">        If `checks` is set to False, no checks will be made for matrix</span>
<span class="sd">        symmetry nor zero diagonals. This is useful if it is known that</span>
<span class="sd">        ``X - X.T1`` is small and ``diag(X)`` is close to zero.</span>
<span class="sd">        These values are ignored any way so they do not disrupt the</span>
<span class="sd">        squareform transformation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        If a condensed distance matrix is passed, a redundant one is</span>
<span class="sd">        returned, or if a redundant one is passed, a condensed distance</span>
<span class="sd">        matrix is returned.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    1. v = squareform(X)</span>

<span class="sd">       Given a square d-by-d symmetric distance matrix X,</span>
<span class="sd">       ``v=squareform(X)`` returns a ``d * (d-1) / 2`` (or</span>
<span class="sd">       `${n \\choose 2}$`) sized vector v.</span>

<span class="sd">      v[{n \\choose 2}-{n-i \\choose 2} + (j-i-1)] is the distance</span>
<span class="sd">      between points i and j. If X is non-square or asymmetric, an error</span>
<span class="sd">      is returned.</span>

<span class="sd">    2. X = squareform(v)</span>

<span class="sd">      Given a d*d(-1)/2 sized v for some integer d&gt;=2 encoding distances</span>
<span class="sd">      as described, X=squareform(v) returns a d by d distance matrix X. The</span>
<span class="sd">      X[i, j] and X[j, i] values are set to</span>
<span class="sd">      v[{n \\choose 2}-{n-i \\choose 2} + (j-u-1)] and all</span>
<span class="sd">      diagonal elements are zero.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubsctype</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;A double array must be passed.&#39;</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">force</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;tomatrix&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Forcing &#39;tomatrix&#39; but input X is not a &quot;</span>
                             <span class="s">&quot;distance vector.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">force</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;tovector&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Forcing &#39;tovector&#39; but input X is not a &quot;</span>
                             <span class="s">&quot;distance matrix.&quot;</span><span class="p">)</span>

    <span class="c"># X = squareform(v)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

        <span class="c"># Grab the closest value to the square root of the number</span>
        <span class="c"># of elements times 2 to see if the number of elements</span>
        <span class="c"># is indeed a binomial coefficient.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)))</span>

        <span class="c"># Check that v is of valid dimensions.</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Incompatible vector size. It must be a binomial &#39;</span>
                             <span class="s">&#39;coefficient n choose 2 for some integer n &gt;= 2.&#39;</span><span class="p">)</span>

        <span class="c"># Allocate memory for the distance matrix.</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

        <span class="c"># Since the C code does not support striding using strides.</span>
        <span class="c"># The dimensions are used instead.</span>
        <span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_arrays_if_base_present</span><span class="p">([</span><span class="n">X</span><span class="p">])</span>

        <span class="c"># Fill in the values of the distance matrix.</span>
        <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">to_squareform_from_vector_wrap</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>

        <span class="c"># Return the distance matrix.</span>
        <span class="k">return</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;The matrix argument must be square.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">checks</span><span class="p">:</span>
            <span class="n">is_valid_dm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;X&#39;</span><span class="p">)</span>

        <span class="c"># One-side of the dimensions is set here.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

        <span class="c"># Create a vector.</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

        <span class="c"># Since the C code does not support striding using strides.</span>
        <span class="c"># The dimensions are used instead.</span>
        <span class="p">[</span><span class="n">X</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_arrays_if_base_present</span><span class="p">([</span><span class="n">X</span><span class="p">])</span>

        <span class="c"># Convert the vector to squareform.</span>
        <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">to_vector_from_squareform_wrap</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&#39;The first argument must be one or two dimensional &#39;</span>
                         <span class="s">&#39;array. A </span><span class="si">%d</span><span class="s">-dimensional array is not &#39;</span>
                         <span class="s">&#39;permitted&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">is_valid_dm</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;D&quot;</span><span class="p">,</span> <span class="n">warning</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if input array is a valid distance matrix.</span>

<span class="sd">    Distance matrices must be 2-dimensional numpy arrays containing</span>
<span class="sd">    doubles. They must have a zero-diagonal, and they must be symmetric.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D : ndarray</span>
<span class="sd">        The candidate object to test for validity.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        The distance matrix should be symmetric. `tol` is the maximum</span>
<span class="sd">        difference between entries ``ij`` and ``ji`` for the distance</span>
<span class="sd">        metric to be considered symmetric.</span>
<span class="sd">    throw : bool, optional</span>
<span class="sd">        An exception is thrown if the distance matrix passed is not valid.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The name of the variable to checked. This is useful if</span>
<span class="sd">        throw is set to True so the offending variable can be identified</span>
<span class="sd">        in the exception message when an exception is thrown.</span>
<span class="sd">    warning : bool, optional</span>
<span class="sd">        Instead of throwing an exception, a warning message is</span>
<span class="sd">        raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    valid : bool</span>
<span class="sd">        True if the variable `D` passed is a valid distance matrix.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Small numerical differences in `D` and `D.T` and non-zeroness of</span>
<span class="sd">    the diagonal are ignored if they are within the tolerance specified</span>
<span class="sd">    by `tol`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">D</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">((</span><span class="s">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s"> must contain doubles &#39;</span>
                                 <span class="s">&#39;(double).&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Distance matrix must contain doubles &#39;</span>
                                <span class="s">&#39;(double).&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s"> must have shape=2 &#39;</span>
                                 <span class="s">&#39;(i.e. be two-dimensional).&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Distance matrix must have shape=2 (i.e. &#39;</span>
                                 <span class="s">&#39;be two-dimensional).&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tol</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">D</span> <span class="o">==</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s"> must be &#39;</span>
                                     <span class="s">&#39;symmetric.&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Distance matrix must be symmetric.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s"> diagonal must &#39;</span>
                                     <span class="s">&#39;be zero.&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Distance matrix diagonal must be zero.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">D</span> <span class="o">-</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s"> must be &#39;</span>
                                      <span class="s">&#39;symmetric within tolerance </span><span class="si">%5.5f</span><span class="s">.&#39;</span><span class="p">)</span>
                                     <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tol</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Distance matrix must be symmetric within&#39;</span>
                                     <span class="s">&#39; tolerance </span><span class="si">%5.5f</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="n">tol</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s"> diagonal must be&#39;</span>
                                      <span class="s">&#39; close to zero within tolerance </span><span class="si">%5.5f</span><span class="s">.&#39;</span><span class="p">)</span>
                                     <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tol</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s"> diagonal must be&#39;</span>
                                      <span class="s">&#39; close to zero within tolerance </span><span class="si">%5.5f</span><span class="s">.&#39;</span><span class="p">)</span>
                                     <span class="o">%</span> <span class="n">tol</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">throw</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">if</span> <span class="n">warning</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">valid</span>


<span class="k">def</span> <span class="nf">is_valid_y</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">warning</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if the input array is a valid condensed distance matrix.</span>

<span class="sd">    Condensed distance matrices must be 1-dimensional</span>
<span class="sd">    numpy arrays containing doubles. Their length must be a binomial</span>
<span class="sd">    coefficient :math:`{n \\choose 2}` for some positive integer n.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The condensed distance matrix.</span>
<span class="sd">    warning : bool, optional</span>
<span class="sd">        Invokes a warning if the variable passed is not a valid</span>
<span class="sd">        condensed distance matrix. The warning message explains why</span>
<span class="sd">        the distance matrix is not valid.  `name` is used when</span>
<span class="sd">        referencing the offending variable.</span>
<span class="sd">    throw : bool, optional</span>
<span class="sd">        Throws an exception if the variable passed is not a valid</span>
<span class="sd">        condensed distance matrix.</span>
<span class="sd">    name : bool, optional</span>
<span class="sd">        Used when referencing the offending variable in the</span>
<span class="sd">        warning or exception message.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">((</span><span class="s">&#39;</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s"> passed as a condensed distance &#39;</span>
                                 <span class="s">&#39;matrix is not a numpy array.&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Variable is not a numpy array.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">((</span><span class="s">&#39;Condensed distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s"> must &#39;</span>
                                 <span class="s">&#39;contain doubles (double).&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Condensed distance matrix must contain &#39;</span>
                                <span class="s">&#39;doubles (double).&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&#39;Condensed distance matrix </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s"> must &#39;</span>
                                  <span class="s">&#39;have shape=1 (i.e. be one-dimensional).&#39;</span><span class="p">)</span>
                                 <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Condensed distance matrix must have shape=1 &#39;</span>
                                 <span class="s">&#39;(i.e. be one-dimensional).&#39;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&#39;Length n of condensed distance matrix &#39;</span>
                                  <span class="s">&#39;</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s"> must be a binomial coefficient, i.e.&#39;</span>
                                  <span class="s">&#39;there must be a k such that &#39;</span>
                                  <span class="s">&#39;(k \choose 2)=n)!&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Length n of condensed distance matrix must &#39;</span>
                                 <span class="s">&#39;be a binomial coefficient, i.e. there must &#39;</span>
                                 <span class="s">&#39;be a k such that (k \choose 2)=n)!&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">throw</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">if</span> <span class="n">warning</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">valid</span>


<span class="k">def</span> <span class="nf">num_obs_dm</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the number of original observations that correspond to a</span>
<span class="sd">    square, redundant distance matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : ndarray</span>
<span class="sd">        The target distance matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    num_obs_dm : int</span>
<span class="sd">        The number of observations in the redundant distance matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">is_valid_dm</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">num_obs_y</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the number of original observations that correspond to a</span>
<span class="sd">    condensed distance matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        Condensed distance matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    n : int</span>
<span class="sd">        The number of observations in the condensed distance matrix `Y`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">is_valid_y</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;Y&#39;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The number of observations cannot be determined on &quot;</span>
                         <span class="s">&quot;an empty distance matrix.&quot;</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Invalid condensed distance matrix passed. Must be &quot;</span>
                         <span class="s">&quot;some k where k=(n choose 2) for some n &gt;= 2.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span> <span class="nf">_row_norms</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norms</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">norms</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_cosine_cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">dm</span><span class="p">):</span>
    <span class="n">XA</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">)</span>
    <span class="n">XB</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">)</span>

    <span class="n">normsA</span> <span class="o">=</span> <span class="n">_row_norms</span><span class="p">(</span><span class="n">XA</span><span class="p">)</span>
    <span class="n">normsB</span> <span class="o">=</span> <span class="n">_row_norms</span><span class="p">(</span><span class="n">XB</span><span class="p">)</span>

    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">dm</span><span class="p">)</span>

    <span class="n">dm</span> <span class="o">/=</span> <span class="n">normsA</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dm</span> <span class="o">/=</span> <span class="n">normsB</span>
    <span class="n">dm</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">dm</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s">&#39;euclidean&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">VI</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes distance between each pair of the two collections of inputs.</span>

<span class="sd">    The following are common calling conventions:</span>

<span class="sd">    1. ``Y = cdist(XA, XB, &#39;euclidean&#39;)``</span>

<span class="sd">       Computes the distance between :math:`m` points using</span>
<span class="sd">       Euclidean distance (2-norm) as the distance metric between the</span>
<span class="sd">       points. The points are arranged as :math:`m`</span>
<span class="sd">       :math:`n`-dimensional row vectors in the matrix X.</span>

<span class="sd">    2. ``Y = cdist(XA, XB, &#39;minkowski&#39;, p)``</span>

<span class="sd">       Computes the distances using the Minkowski distance</span>
<span class="sd">       :math:`||u-v||_p` (:math:`p`-norm) where :math:`p \\geq 1`.</span>

<span class="sd">    3. ``Y = cdist(XA, XB, &#39;cityblock&#39;)``</span>

<span class="sd">       Computes the city block or Manhattan distance between the</span>
<span class="sd">       points.</span>

<span class="sd">    4. ``Y = cdist(XA, XB, &#39;seuclidean&#39;, V=None)``</span>

<span class="sd">       Computes the standardized Euclidean distance. The standardized</span>
<span class="sd">       Euclidean distance between two n-vectors ``u`` and ``v`` is</span>

<span class="sd">       .. math::</span>

<span class="sd">          \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}.</span>

<span class="sd">       V is the variance vector; V[i] is the variance computed over all</span>
<span class="sd">       the i&#39;th components of the points. If not passed, it is</span>
<span class="sd">       automatically computed.</span>

<span class="sd">    5. ``Y = cdist(XA, XB, &#39;sqeuclidean&#39;)``</span>

<span class="sd">       Computes the squared Euclidean distance :math:`||u-v||_2^2` between</span>
<span class="sd">       the vectors.</span>

<span class="sd">    6. ``Y = cdist(XA, XB, &#39;cosine&#39;)``</span>

<span class="sd">       Computes the cosine distance between vectors u and v,</span>

<span class="sd">       .. math::</span>

<span class="sd">          1 - \\frac{u \\cdot v}</span>
<span class="sd">                   {{||u||}_2 {||v||}_2}</span>

<span class="sd">       where :math:`||*||_2` is the 2-norm of its argument ``*``, and</span>
<span class="sd">       :math:`u \\cdot v` is the dot product of :math:`u` and :math:`v`.</span>

<span class="sd">    7. ``Y = cdist(XA, XB, &#39;correlation&#39;)``</span>

<span class="sd">       Computes the correlation distance between vectors u and v. This is</span>

<span class="sd">       .. math::</span>

<span class="sd">          1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}</span>
<span class="sd">                   {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}</span>

<span class="sd">       where :math:`\\bar{v}` is the mean of the elements of vector v,</span>
<span class="sd">       and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.</span>


<span class="sd">    8. ``Y = cdist(XA, XB, &#39;hamming&#39;)``</span>

<span class="sd">       Computes the normalized Hamming distance, or the proportion of</span>
<span class="sd">       those vector elements between two n-vectors ``u`` and ``v``</span>
<span class="sd">       which disagree. To save memory, the matrix ``X`` can be of type</span>
<span class="sd">       boolean.</span>

<span class="sd">    9. ``Y = cdist(XA, XB, &#39;jaccard&#39;)``</span>

<span class="sd">       Computes the Jaccard distance between the points. Given two</span>
<span class="sd">       vectors, ``u`` and ``v``, the Jaccard distance is the</span>
<span class="sd">       proportion of those elements ``u[i]`` and ``v[i]`` that</span>
<span class="sd">       disagree where at least one of them is non-zero.</span>

<span class="sd">    10. ``Y = cdist(XA, XB, &#39;chebyshev&#39;)``</span>

<span class="sd">       Computes the Chebyshev distance between the points. The</span>
<span class="sd">       Chebyshev distance between two n-vectors ``u`` and ``v`` is the</span>
<span class="sd">       maximum norm-1 distance between their respective elements. More</span>
<span class="sd">       precisely, the distance is given by</span>

<span class="sd">       .. math::</span>

<span class="sd">          d(u,v) = \\max_i {|u_i-v_i|}.</span>

<span class="sd">    11. ``Y = cdist(XA, XB, &#39;canberra&#39;)``</span>

<span class="sd">       Computes the Canberra distance between the points. The</span>
<span class="sd">       Canberra distance between two points ``u`` and ``v`` is</span>

<span class="sd">       .. math::</span>

<span class="sd">         d(u,v) = \\sum_i \\frac{|u_i-v_i|}</span>
<span class="sd">                              {|u_i|+|v_i|}.</span>

<span class="sd">    12. ``Y = cdist(XA, XB, &#39;braycurtis&#39;)``</span>

<span class="sd">       Computes the Bray-Curtis distance between the points. The</span>
<span class="sd">       Bray-Curtis distance between two points ``u`` and ``v`` is</span>


<span class="sd">       .. math::</span>

<span class="sd">            d(u,v) = \\frac{\\sum_i (u_i-v_i)}</span>
<span class="sd">                          {\\sum_i (u_i+v_i)}</span>

<span class="sd">    13. ``Y = cdist(XA, XB, &#39;mahalanobis&#39;, VI=None)``</span>

<span class="sd">       Computes the Mahalanobis distance between the points. The</span>
<span class="sd">       Mahalanobis distance between two points ``u`` and ``v`` is</span>
<span class="sd">       :math:`(u-v)(1/V)(u-v)^T` where :math:`(1/V)` (the ``VI``</span>
<span class="sd">       variable) is the inverse covariance. If ``VI`` is not None,</span>
<span class="sd">       ``VI`` will be used as the inverse covariance matrix.</span>

<span class="sd">    14. ``Y = cdist(XA, XB, &#39;yule&#39;)``</span>

<span class="sd">       Computes the Yule distance between the boolean</span>
<span class="sd">       vectors. (see `yule` function documentation)</span>

<span class="sd">    15. ``Y = cdist(XA, XB, &#39;matching&#39;)``</span>

<span class="sd">       Computes the matching distance between the boolean</span>
<span class="sd">       vectors. (see `matching` function documentation)</span>

<span class="sd">    16. ``Y = cdist(XA, XB, &#39;dice&#39;)``</span>

<span class="sd">       Computes the Dice distance between the boolean vectors. (see</span>
<span class="sd">       `dice` function documentation)</span>

<span class="sd">    17. ``Y = cdist(XA, XB, &#39;kulsinski&#39;)``</span>

<span class="sd">       Computes the Kulsinski distance between the boolean</span>
<span class="sd">       vectors. (see `kulsinski` function documentation)</span>

<span class="sd">    18. ``Y = cdist(XA, XB, &#39;rogerstanimoto&#39;)``</span>

<span class="sd">       Computes the Rogers-Tanimoto distance between the boolean</span>
<span class="sd">       vectors. (see `rogerstanimoto` function documentation)</span>

<span class="sd">    19. ``Y = cdist(XA, XB, &#39;russellrao&#39;)``</span>

<span class="sd">       Computes the Russell-Rao distance between the boolean</span>
<span class="sd">       vectors. (see `russellrao` function documentation)</span>

<span class="sd">    20. ``Y = cdist(XA, XB, &#39;sokalmichener&#39;)``</span>

<span class="sd">       Computes the Sokal-Michener distance between the boolean</span>
<span class="sd">       vectors. (see `sokalmichener` function documentation)</span>

<span class="sd">    21. ``Y = cdist(XA, XB, &#39;sokalsneath&#39;)``</span>

<span class="sd">       Computes the Sokal-Sneath distance between the vectors. (see</span>
<span class="sd">       `sokalsneath` function documentation)</span>


<span class="sd">    22. ``Y = cdist(XA, XB, &#39;wminkowski&#39;)``</span>

<span class="sd">       Computes the weighted Minkowski distance between the</span>
<span class="sd">       vectors. (see `wminkowski` function documentation)</span>

<span class="sd">    23. ``Y = cdist(XA, XB, f)``</span>

<span class="sd">       Computes the distance between all pairs of vectors in X</span>
<span class="sd">       using the user supplied 2-arity function f. For example,</span>
<span class="sd">       Euclidean distance between the vectors could be computed</span>
<span class="sd">       as follows::</span>

<span class="sd">         dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))</span>

<span class="sd">       Note that you should avoid passing a reference to one of</span>
<span class="sd">       the distance functions defined in this library. For example,::</span>

<span class="sd">         dm = cdist(XA, XB, sokalsneath)</span>

<span class="sd">       would calculate the pair-wise distances between the vectors in</span>
<span class="sd">       X using the Python function `sokalsneath`. This would result in</span>
<span class="sd">       sokalsneath being called :math:`{n \\choose 2}` times, which</span>
<span class="sd">       is inefficient. Instead, the optimized C version is more</span>
<span class="sd">       efficient, and we call it using the following syntax::</span>

<span class="sd">         dm = cdist(XA, XB, &#39;sokalsneath&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    XA : ndarray</span>
<span class="sd">        An :math:`m_A` by :math:`n` array of :math:`m_A`</span>
<span class="sd">        original observations in an :math:`n`-dimensional space.</span>
<span class="sd">        Inputs are converted to float type.</span>
<span class="sd">    XB : ndarray</span>
<span class="sd">        An :math:`m_B` by :math:`n` array of :math:`m_B`</span>
<span class="sd">        original observations in an :math:`n`-dimensional space.</span>
<span class="sd">        Inputs are converted to float type.</span>
<span class="sd">    metric : str or callable, optional</span>
<span class="sd">        The distance metric to use.  If a string, the distance function can be</span>
<span class="sd">        &#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;, &#39;cityblock&#39;, &#39;correlation&#39;,</span>
<span class="sd">        &#39;cosine&#39;, &#39;dice&#39;, &#39;euclidean&#39;, &#39;hamming&#39;, &#39;jaccard&#39;, &#39;kulsinski&#39;,</span>
<span class="sd">        &#39;mahalanobis&#39;, &#39;matching&#39;, &#39;minkowski&#39;, &#39;rogerstanimoto&#39;, &#39;russellrao&#39;,</span>
<span class="sd">        &#39;seuclidean&#39;, &#39;sokalmichener&#39;, &#39;sokalsneath&#39;, &#39;sqeuclidean&#39;,</span>
<span class="sd">        &#39;wminkowski&#39;, &#39;yule&#39;.</span>
<span class="sd">    w : ndarray, optional</span>
<span class="sd">        The weight vector (for weighted Minkowski).</span>
<span class="sd">    p : scalar, optional</span>
<span class="sd">        The p-norm to apply (for Minkowski, weighted and unweighted)</span>
<span class="sd">    V : ndarray, optional</span>
<span class="sd">        The variance vector (for standardized Euclidean).</span>
<span class="sd">    VI : ndarray, optional</span>
<span class="sd">        The inverse of the covariance matrix (for Mahalanobis).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        A :math:`m_A` by :math:`m_B` distance matrix is returned.</span>
<span class="sd">        For each :math:`i` and :math:`j`, the metric</span>
<span class="sd">        ``dist(u=XA[i], v=XB[j])`` is computed and stored in the</span>
<span class="sd">        :math:`ij` th entry.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        An exception is thrown if `XA` and `XB` do not have</span>
<span class="sd">        the same number of columns.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find the Euclidean distances between four 2-D coordinates:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; coords = [(35.0456, -85.2672),</span>
<span class="sd">    ...           (35.1174, -89.9711),</span>
<span class="sd">    ...           (35.9728, -83.9422),</span>
<span class="sd">    ...           (36.1667, -86.7833)]</span>
<span class="sd">    &gt;&gt;&gt; distance.cdist(coords, coords, &#39;euclidean&#39;)</span>
<span class="sd">    array([[ 0.    ,  4.7044,  1.6172,  1.8856],</span>
<span class="sd">           [ 4.7044,  0.    ,  6.0893,  3.3561],</span>
<span class="sd">           [ 1.6172,  6.0893,  0.    ,  2.8477],</span>
<span class="sd">           [ 1.8856,  3.3561,  2.8477,  0.    ]])</span>


<span class="sd">    Find the Manhattan distance from a 3-D point to the corners of the unit</span>
<span class="sd">    cube:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[0, 0, 0],</span>
<span class="sd">    ...               [0, 0, 1],</span>
<span class="sd">    ...               [0, 1, 0],</span>
<span class="sd">    ...               [0, 1, 1],</span>
<span class="sd">    ...               [1, 0, 0],</span>
<span class="sd">    ...               [1, 0, 1],</span>
<span class="sd">    ...               [1, 1, 0],</span>
<span class="sd">    ...               [1, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([[ 0.1,  0.2,  0.4]])</span>
<span class="sd">    &gt;&gt;&gt; distance.cdist(a, b, &#39;cityblock&#39;)</span>
<span class="sd">    array([[ 0.7],</span>
<span class="sd">           [ 0.9],</span>
<span class="sd">           [ 1.3],</span>
<span class="sd">           [ 1.5],</span>
<span class="sd">           [ 1.5],</span>
<span class="sd">           [ 1.7],</span>
<span class="sd">           [ 2.1],</span>
<span class="sd">           [ 2.3]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="c">#         21. Y = cdist(XA, XB, &#39;test_Y&#39;)</span>
<span class="c">#</span>
<span class="c">#           Computes the distance between all pairs of vectors in X</span>
<span class="c">#           using the distance metric Y but with a more succint,</span>
<span class="c">#           verifiable, but less efficient implementation.</span>

    <span class="n">XA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">XB</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>

    <span class="c">#if np.issubsctype(X, np.floating) and not np.issubsctype(X, np.double):</span>
    <span class="c">#    raise TypeError(&#39;Floating point arrays must be 64-bit (got %r).&#39; %</span>
    <span class="c">#    (X.dtype.type,))</span>

    <span class="c"># The C code doesn&#39;t do striding.</span>
    <span class="p">[</span><span class="n">XA</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_arrays_if_base_present</span><span class="p">([</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">)])</span>
    <span class="p">[</span><span class="n">XB</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_arrays_if_base_present</span><span class="p">([</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">)])</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">XA</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">sB</span> <span class="o">=</span> <span class="n">XB</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;XA must be a 2-dimensional array.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;XB must be a 2-dimensional array.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sB</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;XA and XB must have the same number of columns &#39;</span>
                         <span class="s">&#39;(i.e. feature dimension.)&#39;</span><span class="p">)</span>

    <span class="n">mA</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mB</span> <span class="o">=</span> <span class="n">sB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">minkowski</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mA</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mB</span><span class="p">):</span>
                    <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">minkowski</span><span class="p">(</span><span class="n">XA</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">XB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">wminkowski</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mA</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mB</span><span class="p">):</span>
                    <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">wminkowski</span><span class="p">(</span><span class="n">XA</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">XB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">seuclidean</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mA</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mB</span><span class="p">):</span>
                    <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">seuclidean</span><span class="p">(</span><span class="n">XA</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">XB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">V</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="n">mahalanobis</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mA</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mB</span><span class="p">):</span>
                    <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mahalanobis</span><span class="p">(</span><span class="n">XA</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">XB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">V</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mA</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mB</span><span class="p">):</span>
                    <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">XA</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">XB</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">mstr</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c">#if XA.dtype != np.double and \</span>
        <span class="c">#       (mstr != &#39;hamming&#39; and mstr != &#39;jaccard&#39;):</span>
        <span class="c">#    TypeError(&#39;A double array must be passed.&#39;)</span>
        <span class="k">if</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s">&#39;euclid&#39;</span><span class="p">,</span> <span class="s">&#39;eu&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">]):</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_euclidean_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;sqeuclidean&#39;</span><span class="p">,</span> <span class="s">&#39;sqe&#39;</span><span class="p">,</span> <span class="s">&#39;sqeuclid&#39;</span><span class="p">]):</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_sqeuclidean_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;cityblock&#39;</span><span class="p">,</span> <span class="s">&#39;cblock&#39;</span><span class="p">,</span> <span class="s">&#39;cb&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">]):</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_city_block_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                 <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;hamming&#39;</span><span class="p">,</span> <span class="s">&#39;hamm&#39;</span><span class="p">,</span> <span class="s">&#39;ha&#39;</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">XA</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_hamming_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                       <span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span>
                                                       <span class="n">dm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_hamming_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                  <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s">&#39;jacc&#39;</span><span class="p">,</span> <span class="s">&#39;ja&#39;</span><span class="p">,</span> <span class="s">&#39;j&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">XA</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_jaccard_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                       <span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span>
                                                       <span class="n">dm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_jaccard_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                  <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;chebychev&#39;</span><span class="p">,</span> <span class="s">&#39;chebyshev&#39;</span><span class="p">,</span> <span class="s">&#39;cheby&#39;</span><span class="p">,</span> <span class="s">&#39;cheb&#39;</span><span class="p">,</span> <span class="s">&#39;ch&#39;</span><span class="p">]):</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_chebyshev_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;minkowski&#39;</span><span class="p">,</span> <span class="s">&#39;mi&#39;</span><span class="p">,</span> <span class="s">&#39;m&#39;</span><span class="p">,</span> <span class="s">&#39;pnorm&#39;</span><span class="p">]):</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_minkowski_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;wminkowski&#39;</span><span class="p">,</span> <span class="s">&#39;wmi&#39;</span><span class="p">,</span> <span class="s">&#39;wm&#39;</span><span class="p">,</span> <span class="s">&#39;wpnorm&#39;</span><span class="p">]):</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_weighted_minkowski_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                         <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span>
                                                         <span class="n">dm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
                                                         <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;seuclidean&#39;</span><span class="p">,</span> <span class="s">&#39;se&#39;</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Variance vector V must be a numpy array&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Variance vector V must contain doubles.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Variance vector V must be &#39;</span>
                                     <span class="s">&#39;one-dimensional.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Variance vector V must be of the same &#39;</span>
                                     <span class="s">&#39;dimension as the vectors on which the &#39;</span>
                                     <span class="s">&#39;distances are computed.&#39;</span><span class="p">)</span>
                <span class="c"># The C code doesn&#39;t do striding.</span>
                <span class="p">[</span><span class="n">VV</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_arrays_if_base_present</span><span class="p">([</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">V</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">])</span>
                <span class="n">VV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">X</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">del</span> <span class="n">X</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_seuclidean_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                 <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">VV</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;cosine&#39;</span><span class="p">,</span> <span class="s">&#39;cos&#39;</span><span class="p">]):</span>
            <span class="n">_cosine_cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;correlation&#39;</span><span class="p">,</span> <span class="s">&#39;co&#39;</span><span class="p">]):</span>
            <span class="n">XA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">XB</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">XA</span> <span class="o">-=</span> <span class="n">XA</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">XB</span> <span class="o">-=</span> <span class="n">XB</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">_cosine_cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;mahalanobis&#39;</span><span class="p">,</span> <span class="s">&#39;mahal&#39;</span><span class="p">,</span> <span class="s">&#39;mah&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">VI</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">VI</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">VI</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">VI</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;VI must be a numpy array.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">VI</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;The array must contain 64-bit floats.&#39;</span><span class="p">)</span>
                <span class="p">[</span><span class="n">VI</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_arrays_if_base_present</span><span class="p">([</span><span class="n">VI</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">mA</span> <span class="o">+</span> <span class="n">mB</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
                    <span class="c"># There are fewer observations than the dimension of</span>
                    <span class="c"># the observations.</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The number of observations (</span><span class="si">%d</span><span class="s">) is too &quot;</span>
                                     <span class="s">&quot;small; the covariance matrix is &quot;</span>
                                     <span class="s">&quot;singular. For observations with </span><span class="si">%d</span><span class="s"> &quot;</span>
                                     <span class="s">&quot;dimensions, at least </span><span class="si">%d</span><span class="s"> observations &quot;</span>
                                     <span class="s">&quot;are required.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">])</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
                <span class="n">X</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">del</span> <span class="n">X</span>
                <span class="n">VI</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="c"># (u-v)V^(-1)(u-v)^T</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_mahalanobis_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                  <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span>
                                                  <span class="n">VI</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;canberra&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_canberra_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                               <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;braycurtis&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_bray_curtis_wrap</span><span class="p">(</span><span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                  <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;yule&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_yule_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                <span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;matching&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_matching_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                    <span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;kulsinski&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_kulsinski_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                     <span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;dice&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_dice_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                <span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;rogerstanimoto&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_rogerstanimoto_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                          <span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span>
                                                          <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;russellrao&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_russellrao_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                      <span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;sokalmichener&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_sokalmichener_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                         <span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span>
                                                         <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span> <span class="o">==</span> <span class="s">&#39;sokalsneath&#39;</span><span class="p">:</span>
            <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_sokalsneath_bool_wrap</span><span class="p">(</span><span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XA</span><span class="p">),</span>
                                                       <span class="n">_convert_to_bool</span><span class="p">(</span><span class="n">XB</span><span class="p">),</span>
                                                       <span class="n">dm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_euclidean&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">euclidean</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_seuclidean&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">seuclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">V</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_sqeuclidean&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">sqeuclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_braycurtis&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">braycurtis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_mahalanobis&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">VI</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">])</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">VI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
                <span class="n">X</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">del</span> <span class="n">X</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">VI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">VI</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
            <span class="p">[</span><span class="n">VI</span><span class="p">]</span> <span class="o">=</span> <span class="n">_copy_arrays_if_base_present</span><span class="p">([</span><span class="n">VI</span><span class="p">])</span>
            <span class="c"># (u-v)V^(-1)(u-v)^T</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">mahalanobis</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">VI</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_canberra&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">canberra</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_cityblock&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">cityblock</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_minkowski&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">minkowski</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_wminkowski&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">wminkowski</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_correlation&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">correlation</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_hamming&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">hamming</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_jaccard&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">jaccard</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_chebyshev&#39;</span> <span class="ow">or</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_chebychev&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">chebyshev</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_yule&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">yule</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_matching&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">matching</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_dice&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">dice</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_kulsinski&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">kulsinski</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_rogerstanimoto&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">rogerstanimoto</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_russellrao&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">russellrao</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_sokalsneath&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">sokalsneath</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s">&#39;test_sokalmichener&#39;</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">sokalmichener</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Unknown Distance Metric: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">mstr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;2nd argument metric must be a string identifier &#39;</span>
                        <span class="s">&#39;or a function.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dm</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Ariel Rokem and Jason Yeatman, The University of Washington eScience Institute.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>